syntax = "proto3";

import "gogoproto/gogo.proto";
import "google/protobuf/any.proto";
import "prompb/types.proto";

message Label {
  string name = 1;
  string value = 2;
}

message LabelSet {
  repeated Label labels = 1 [(gogoproto.nullable) = false];
}

message Chunk {
  enum Encoding {
    XOR = 0;
  }

  Encoding type = 1;
  bytes data = 2;
}

message AggregateChunk {
  int64 min_time = 1;
  int64 max_time = 2;

  Chunk raw = 3;
  Chunk count = 4;
  Chunk sum = 5;
  Chunk min = 6;
  Chunk max = 7;
  Chunk counter = 8;
}

message Series {
  repeated Label labels = 1 [(gogoproto.nullable) = false];
  repeated AggregateChunk chunks = 2 [(gogoproto.nullable) = false];
}

message TSDB {
  string tenant = 1;
  uint32 partition = 2;
  uint32 replication = 3;
}

service Store {
  // Info returns meta information about a store
  // eg tenants the store contains as well as thme rage that is available
  rpc Info(InfoRequest) returns (InfoResponse);

  // Series streams each Series for given label matchers and time range
  rpc Series(SeriesRequest) returns (stream SeriesResponse);

  rpc LabelNames(LabelNamesRequest) returns (LabelNamesResponse);

  rpc LabelValues(LabelValuesRequest) returns (LabelValuesResponse);
}

message InfoRequest {

}

message InfoResponse {
  int64 min_time = 1;
  int64 max_time = 2;
  repeated TSDB tsdbs = 3 [(gogoproto.nullable) = false];
}

message LabelMatcher {
  enum Type {
    EQ = 0;
    NE = 1;
    RE = 2;
    NRE = 3;
  }

  Type type = 1;
  string name = 2;
  string value = 3;
}


enum Aggregate {
  RAW = 0;
  COUNT = 1;
  SUM = 2;
  MIN = 3;
  MAX = 4;
  COUNTER = 5;
}

/// PartialResponseStrategy controls partial response handling.
enum PartialResponseStrategy {
  /// WARN strategy tells server to treat any error that will related to single StoreAPI (e.g missing chunk series because of underlying
  /// storeAPI is temporarily not available) as warning which will not fail the whole query (still OK response).
  /// Server should produce those as a warnings field in response.
  WARN = 0;
  /// ABORT strategy tells server to treat any error that will related to single StoreAPI (e.g missing chunk series because of underlying
  /// storeAPI is temporarily not available) as the gRPC error that aborts the query.
  ///
  /// This is especially useful for any rule/alert evaluations on top of StoreAPI which usually does not tolerate partial
  /// errors.
  ABORT = 1;
}

message SeriesRequest {
  string tenant = 1;
  int64 min_time = 2;
  int64 max_time = 3;

  repeated LabelMatcher matchers = 4 [(gogoproto.nullable) = false];

  int64 max_resolution_window = 5;
  repeated Aggregate aggregates = 6;

  PartialResponseStrategy partial = 7;

  bool skip_chunks = 8;

  google.protobuf.Any hints = 9;
}

message SeriesResponse {
  oneof result {

    Series series = 1;
    string warns = 2;
    google.protobuf.Any hints = 3;
  }
}

message LabelNamesRequest {
  string tenant = 1;

  int64 start = 2;
  int64 end = 3;
  PartialResponseStrategy partial = 4;
}

message LabelNamesResponse {
  repeated string name = 1;
  repeated string warnings = 2;
}

message LabelValuesRequest {
  string tenant = 1;

  int64 start = 2;
  int64 end = 3;
  PartialResponseStrategy partial = 4;
}

message LabelValuesResponse {
  repeated string values = 1;
  repeated string warnings = 2;
}

service Appender {
  rpc Append(AppendRequest) returns (AppendResponse);
}

message AppendRequest {
  string tenant = 1;

  repeated prometheus_copy.TimeSeries timeseries = 2 [(gogoproto.nullable) = false];
}

message AppendResponse {
  string error = 1;
}
